var fs = require("fs");
var path = require("path");
var minimatch = require("minimatch");

function findBase(pattern) {
  return pattern.replace(/[*?].*$/, "").replace(/[^/]*$/, "");
}

exports.globSync = function(pattern, options) {
  var files = [];

  // Normalize pattern to absolute path
  var fullPattern = path.resolve(pattern);
  // For windows support
  fullPattern = fullPattern.replace(/\\/g, "\/");
  // Determine deepest level non-wildcard path on absolute pattern
  var fullBase = findBase(fullPattern);
  // Determine deepest level non-wildcard on original pattern
  var base = findBase(pattern);

  // If no options specified, default to empty object
  options = options || {};

  // Add the folder to start from
  files.push(fullBase);

  function recurseDirectory(root) {
    // Iterate over all found files in the directory
    fs.readdirSync(root).forEach(function(file) {
      // Ensure file path is absolute
      file = path.join(root, file);

      // Recurse if found a new directory
      if (fs.statSync(file).isDirectory()) {
        // Need to add a trailing slash for directories
        files.push(file);

        recurseDirectory(file);
      } else {
        // Add to files array to test 
        files.push(file);
      }
    });
  }

  // Start recursing from the root
  recurseDirectory(fullBase);

  // Use @isaacs minimatch library to create a match of all the globs
  return minimatch.match(files, fullPattern, options);
};

